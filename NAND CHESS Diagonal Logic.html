<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NAND CHESS — Diagonal Logic Engine</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap');
  :root {
    --bg: #080c0a;
    --grid: #0d1a12;
    --cell-dark: #0a1510;
    --cell-light: #0f2018;
    --accent: #00ff88;
    --amber: #ffaa00;
    --red: #ff3355;
    --dim: #1a3326;
    --text: #a0ffcc;
    --player: #00ccff;
    --ai: #ff6622;
    --pressure: rgba(255,100,0,0.12);
    --selected: rgba(0,255,136,0.25);
    --valid: rgba(0,255,136,0.15);
  }
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }
  /* scanline overlay */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.07) 2px,
      rgba(0,0,0,0.07) 4px
    );
    pointer-events: none;
    z-index: 100;
  }
  header {
    width: 100%;
    padding: 18px 40px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--dim);
    background: rgba(0,0,0,0.4);
  }
  .logo {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: 1.4rem;
    letter-spacing: 0.2em;
    color: var(--accent);
    text-shadow: 0 0 20px var(--accent);
  }
  .logo span { color: var(--amber); }
  .status-bar {
    font-size: 0.75rem;
    color: var(--amber);
    letter-spacing: 0.1em;
  }
  .main {
    display: flex;
    gap: 32px;
    padding: 32px;
    align-items: flex-start;
    justify-content: center;
    width: 100%;
    max-width: 1100px;
  }
  /* BOARD */
  .board-wrap {
    position: relative;
    flex-shrink: 0;
  }
  .board {
    display: grid;
    grid-template-columns: repeat(8, 72px);
    grid-template-rows: repeat(8, 72px);
    border: 1px solid var(--dim);
    box-shadow: 0 0 60px rgba(0,255,136,0.08), 0 0 120px rgba(0,255,136,0.04);
    position: relative;
  }
  .cell {
    width: 72px;
    height: 72px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    transition: background 0.15s;
    font-size: 2rem;
    user-select: none;
  }
  .cell.dark { background: var(--cell-dark); }
  .cell.light { background: var(--cell-light); }
  .cell.selected { background: var(--selected) !important; box-shadow: inset 0 0 0 2px var(--accent); }
  .cell.valid-move::after {
    content: '';
    position: absolute;
    width: 24px; height: 24px;
    border-radius: 50%;
    background: var(--valid);
    border: 1px solid rgba(0,255,136,0.4);
  }
  .cell.valid-move.has-piece::after {
    width: 100%; height: 100%;
    border-radius: 0;
    background: rgba(255,50,50,0.15);
    border: 2px solid rgba(255,80,80,0.5);
  }
  .cell.pressure-1 { background: rgba(255,100,0,0.06) !important; }
  .cell.pressure-2 { background: rgba(255,100,0,0.12) !important; }
  .cell.pressure-3 { background: rgba(255,100,0,0.2) !important; }
  .cell.pressure-4 { background: rgba(255,50,0,0.3) !important; }
  .cell.last-move { box-shadow: inset 0 0 0 2px rgba(255,170,0,0.5); }
  /* diagonal threat lines */
  .cell.diagonal-threat::before {
    content: '';
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, transparent 40%, rgba(255,100,0,0.1) 50%, transparent 60%);
    pointer-events: none;
  }
  .piece {
    width: 56px; height: 56px;
    display: flex; align-items: center; justify-content: center;
    font-size: 2.2rem;
    position: relative;
    z-index: 2;
    transition: transform 0.1s;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.8));
  }
  .cell:hover .piece { transform: scale(1.08); }
  /* rank/file labels */
  .labels-left {
    position: absolute;
    left: -24px; top: 0;
    height: 100%;
    display: flex; flex-direction: column;
  }
  .labels-left span, .labels-bottom span {
    font-size: 0.65rem;
    color: #2a5040;
    display: flex; align-items: center; justify-content: center;
  }
  .labels-left span { height: 72px; }
  .labels-bottom {
    position: absolute;
    bottom: -20px; left: 0;
    width: 100%;
    display: flex;
  }
  .labels-bottom span { width: 72px; }
  /* PANEL */
  .panel {
    display: flex;
    flex-direction: column;
    gap: 16px;
    width: 280px;
    min-height: 580px;
  }
  .panel-block {
    background: rgba(0,20,12,0.8);
    border: 1px solid var(--dim);
    padding: 16px;
  }
  .panel-title {
    font-family: 'Orbitron', monospace;
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    color: var(--amber);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--dim);
  }
  .turn-indicator {
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 0.85rem;
  }
  .turn-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
    animation: pulse 1.5s infinite;
  }
  .turn-dot.ai { background: var(--ai); box-shadow: 0 0 8px var(--ai); }
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }
  /* NAND pressure meter */
  .pressure-meter {
    margin-top: 8px;
  }
  .meter-label {
    font-size: 0.7rem;
    color: #2a5040;
    margin-bottom: 4px;
    letter-spacing: 0.1em;
  }
  .meter-bar {
    height: 6px;
    background: var(--dim);
    border-radius: 0;
    overflow: hidden;
    margin-bottom: 8px;
  }
  .meter-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--amber), var(--red));
    transition: width 0.5s ease;
    box-shadow: 0 0 8px rgba(255,100,0,0.5);
  }
  /* NAND log */
  .nand-log {
    font-size: 0.68rem;
    color: #2a5040;
    height: 160px;
    overflow-y: auto;
    line-height: 1.7;
  }
  .nand-log::-webkit-scrollbar { width: 3px; }
  .nand-log::-webkit-scrollbar-thumb { background: var(--dim); }
  .log-entry {
    border-left: 2px solid transparent;
    padding-left: 8px;
    transition: color 0.2s;
  }
  .log-entry.ai { border-color: var(--ai); color: rgba(255,102,34,0.7); }
  .log-entry.player { border-color: var(--player); color: rgba(0,204,255,0.7); }
  .log-entry.system { border-color: var(--accent); color: rgba(0,255,136,0.5); }
  /* move history */
  .move-list {
    font-size: 0.72rem;
    color: var(--text);
    opacity: 0.7;
    height: 100px;
    overflow-y: auto;
    display: grid;
    grid-template-columns: 20px 1fr 1fr;
    gap: 2px 8px;
    align-content: start;
  }
  .move-list::-webkit-scrollbar { width: 3px; }
  .move-list::-webkit-scrollbar-thumb { background: var(--dim); }
  .move-num { color: var(--dim); }
  .move-player { color: var(--player); }
  .move-ai { color: var(--ai); }
  .btn {
    background: transparent;
    border: 1px solid var(--accent);
    color: var(--accent);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.75rem;
    letter-spacing: 0.15em;
    padding: 10px 16px;
    cursor: pointer;
    transition: all 0.2s;
    width: 100%;
  }
  .btn:hover {
    background: rgba(0,255,136,0.1);
    box-shadow: 0 0 12px rgba(0,255,136,0.3);
  }
  .game-over-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 200;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 24px;
  }
  .game-over-overlay.show { display: flex; }
  .game-over-title {
    font-family: 'Orbitron', monospace;
    font-size: 3rem;
    font-weight: 900;
    letter-spacing: 0.3em;
  }
  .game-over-title.win { color: var(--accent); text-shadow: 0 0 40px var(--accent); }
  .game-over-title.lose { color: var(--red); text-shadow: 0 0 40px var(--red); }
  .game-over-sub {
    font-size: 0.9rem;
    color: var(--amber);
    letter-spacing: 0.2em;
  }
  .nand-circuit {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    flex-wrap: wrap;
  }
  .nand-cell {
    width: 18px; height: 18px;
    border: 1px solid var(--dim);
    display: flex; align-items: center; justify-content: center;
    font-size: 0.5rem;
    color: #1a3326;
    transition: all 0.3s;
    position: relative;
  }
  .nand-cell.active {
    border-color: var(--amber);
    color: var(--amber);
    box-shadow: 0 0 6px rgba(255,170,0,0.4);
    background: rgba(255,170,0,0.05);
  }
  .nand-cell.fired {
    border-color: var(--red);
    color: var(--red);
    box-shadow: 0 0 8px rgba(255,51,85,0.6);
    background: rgba(255,51,85,0.1);
    animation: nandfire 0.4s ease;
  }
  @keyframes nandfire {
    0% { transform: scale(1.4); }
    100% { transform: scale(1); }
  }
</style>
</head>
<body>
<header>
  <div class="logo">NAND <span>CHESS</span></div>
  <div class="status-bar" id="statusBar">SYSTEM READY — DIAGONAL LOGIC ENGINE v1.0</div>
</header>
<div class="main">
  <div class="board-wrap">
    <div class="labels-left" id="labelsLeft"></div>
    <div class="board" id="board"></div>
    <div class="labels-bottom" id="labelsBottom"></div>
  </div>
  <div class="panel">
    <div class="panel-block">
      <div class="panel-title">TURN STATE</div>
      <div class="turn-indicator">
        <div class="turn-dot" id="turnDot"></div>
        <span id="turnText">YOUR MOVE</span>
      </div>
      <div class="pressure-meter" style="margin-top:16px">
        <div class="meter-label">AI DIAGONAL PRESSURE</div>
        <div class="meter-bar"><div class="meter-fill" id="pressureFill" style="width:0%"></div></div>
        <div class="meter-label">NAND CONSTRAINT INDEX</div>
        <div class="meter-bar"><div class="meter-fill" id="nandFill" style="width:0%; background: linear-gradient(90deg, #00cc88, #00ffaa);"></div></div>
      </div>
    </div>
    <div class="panel-block">
      <div class="panel-title">CYCLIC NAND RING — 8-CELL</div>
      <div class="nand-circuit" id="nandCircuit"></div>
      <div style="font-size:0.62rem; color:#1a3326; margin-top:8px; line-height:1.6;">
        T = A ⊕ B ⊕ NAND(A,B)<br>
        Phase: <span id="phaseDisplay" style="color:var(--amber)">0π/4</span> | Remainder: <span id="remainderDisplay" style="color:var(--accent)">0x00</span>
      </div>
    </div>
    <div class="panel-block">
      <div class="panel-title">NAND DECISION LOG</div>
      <div class="nand-log" id="nandLog"></div>
    </div>
    <div class="panel-block">
      <div class="panel-title">MOVE HISTORY</div>
      <div class="move-list" id="moveList"></div>
    </div>
    <button class="btn" onclick="resetGame()">[ NEW GAME ]</button>
  </div>
</div>
<div class="game-over-overlay" id="gameOverlay">
  <div class="game-over-title" id="gameOverTitle">CHECKMATE</div>
  <div class="game-over-sub" id="gameOverSub">NAND ENGINE PREVAILS</div>
  <button class="btn" style="width:200px" onclick="resetGame()">[ RESET ]</button>
</div>
<script>
// ============================================================
// CHESS ENGINE CORE
// ============================================================
const PIECES = {
  wK:'♔', wQ:'♕', wR:'♖', wB:'♗', wN:'♘', wP:'♙',
  bK:'♚', bQ:'♛', bR:'♜', bB:'♝', bN:'♞', bP:'♟'
};
const FILES = ['a','b','c','d','e','f','g','h'];
const RANKS = ['8','7','6','5','4','3','2','1'];
let board = [];
let selected = null;
let validMoves = [];
let currentTurn = 'w';
let gameActive = true;
let moveHistory = [];
let nandRing = new Array(8).fill(0);
let nandPhase = 0;
let nandRemainder = 0;
let pressureMap = new Array(64).fill(0);
let lastMoveSquares = [];
let moveCount = 0;

// NAND cyclic ring computation
function nandGate(a, b) { return !(a && b) ? 1 : 0; }
function cycleNANDRing(inputs) {
  let remainder = 0;
  const fired = [];
  for (let i = 0; i < 8; i++) {
    const a = inputs[i] & 1;
    const b = (nandRing[i] ^ (i > 0 ? nandRing[i-1] : nandRemainder)) & 1;
    const nandOut = nandGate(a, b);
    const T = a ^ b ^ nandOut;
    remainder = (remainder ^ T) & 1;
    nandRing[i] = nandOut;
    if (T) fired.push(i);
  }
  nandRemainder = (nandRemainder ^ remainder) & 0xFF;
  nandPhase = (nandPhase + 1) % 8;
  return { remainder, fired };
}

// ============================================================
// BOARD SETUP
// ============================================================
function initBoard() {
  board = new Array(64).fill(null);
  // Black pieces (AI) - top
  const backRow = ['R','N','B','Q','K','B','N','R'];
  for (let f = 0; f < 8; f++) {
    board[f] = 'b' + backRow[f];
    board[8 + f] = 'bP';
  }
  // White pieces (Player) - bottom
  for (let f = 0; f < 8; f++) {
    board[48 + f] = 'wP';
    board[56 + f] = 'w' + backRow[f];
  }
}
function idx(r, f) { return r * 8 + f; }
function rankOf(i) { return Math.floor(i / 8); }
function fileOf(i) { return i % 8; }
function inBounds(r, f) { return r >= 0 && r < 8 && f >= 0 && f < 8; }
function colorOf(piece) { return piece ? piece[0] : null; }
function typeOf(piece) { return piece ? piece.slice(1) : null; }

// ============================================================
// MOVE GENERATION
// ============================================================
function getLegalMoves(square, brd = board, turn = currentTurn) {
  const piece = brd[square];
  if (!piece || colorOf(piece) !== turn) return [];
  const moves = getPseudoMoves(square, brd, turn);
  return moves.filter(to => {
    const nb = brd.slice();
    nb[to] = nb[square];
    nb[square] = null;
    if (typeOf(nb[to]) === 'P' && (rankOf(to) === 0 || rankOf(to) === 7)) nb[to] = turn + 'Q';
    return !isInCheck(turn, nb);
  });
}
function getPseudoMoves(square, brd, color) {
  const piece = brd[square];
  const t = typeOf(piece);
  const r = rankOf(square), f = fileOf(square);
  const enemy = color === 'w' ? 'b' : 'w';
  const moves = [];
  function slide(dr, df) {
    let nr = r + dr, nf = f + df;
    while (inBounds(nr, nf)) {
      const s = idx(nr, nf);
      if (brd[s]) {
        if (colorOf(brd[s]) === enemy) moves.push(s);
        break;
      }
      moves.push(s);
      nr += dr; nf += df;
    }
  }
  function jump(dr, df) {
    const nr = r + dr, nf = f + df;
    if (inBounds(nr, nf)) {
      const s = idx(nr, nf);
      if (!brd[s] || colorOf(brd[s]) === enemy) moves.push(s);
    }
  }
  if (t === 'P') {
    const dir = color === 'w' ? -1 : 1;
    const startRank = color === 'w' ? 6 : 1;
    const nr = r + dir;
    if (inBounds(nr, f) && !brd[idx(nr, f)]) {
      moves.push(idx(nr, f));
      if (r === startRank && !brd[idx(r + 2*dir, f)]) moves.push(idx(r + 2*dir, f));
    }
    [-1, 1].forEach(df => {
      if (inBounds(nr, f + df) && brd[idx(nr, f + df)] && colorOf(brd[idx(nr, f + df)]) === enemy)
        moves.push(idx(nr, f + df));
    });
  }
  if (t === 'R' || t === 'Q') { [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,df]) => slide(dr,df)); }
  if (t === 'B' || t === 'Q') { [[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,df]) => slide(dr,df)); }
  if (t === 'N') { [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]].forEach(([dr,df]) => jump(dr,df)); }
  if (t === 'K') { [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,df]) => jump(dr,df)); }
  return moves;
}
function isInCheck(color, brd) {
  const kingSquare = brd.findIndex(p => p === color + 'K');
  if (kingSquare < 0) return true;
  const enemy = color === 'w' ? 'b' : 'w';
  for (let s = 0; s < 64; s++) {
    if (colorOf(brd[s]) === enemy) {
      if (getPseudoMoves(s, brd, enemy).includes(kingSquare)) return true;
    }
  }
  return false;
}
function hasAnyLegalMove(color, brd = board) {
  for (let s = 0; s < 64; s++) {
    if (colorOf(brd[s]) === color) {
      if (getLegalMoves(s, brd, color).length > 0) return true;
    }
  }
  return false;
}

// ============================================================
// ADVANCED DIAGONAL HELPERS
// ============================================================
const KEY_DIAGS = [];
for (let i = 0; i < 8; i++) {
  KEY_DIAGS.push(idx(i, i));      // a1-h8
  KEY_DIAGS.push(idx(7 - i, i));  // h1-a8
}

function getDiagTargets(square, brd, color) {
  const piece = brd[square];
  if (!piece || colorOf(piece) !== color) return [];
  const t = typeOf(piece);
  const r = rankOf(square), f = fileOf(square);
  const targets = [];
  const diagDirs = [[1,1],[1,-1],[-1,1],[-1,-1]];

  if (t === 'B' || t === 'Q') {
    diagDirs.forEach(([dr, df]) => {
      let nr = r + dr, nf = f + df;
      while (inBounds(nr, nf)) {
        targets.push(idx(nr, nf));
        if (brd[idx(nr, nf)]) break;
        nr += dr; nf += df;
      }
    });
  }
  if (t === 'P') {
    const dir = color === 'w' ? -1 : 1;
    [-1, 1].forEach(df => {
      const nr = r + dir, nf = f + df;
      if (inBounds(nr, nf)) targets.push(idx(nr, nf));
    });
  }
  if (t === 'K') {
    diagDirs.forEach(([dr, df]) => {
      const nr = r + dr, nf = f + df;
      if (inBounds(nr, nf)) targets.push(idx(nr, nf));
    });
  }
  return targets;
}

function diagMobility(brd, color) {
  let total = 0;
  for (let s = 0; s < 64; s++) {
    if (colorOf(brd[s]) === color) {
      total += getDiagTargets(s, brd, color).length;
    }
  }
  return total;
}

function keyDiagControl(brd, color) {
  const enemy = color === 'b' ? 'w' : 'b';
  let score = 0;
  for (let ks of KEY_DIAGS) {
    const p = brd[ks];
    if (p && colorOf(p) === color) score += 4;
    if (p && colorOf(p) === enemy) score -= 3;
    for (let s = 0; s < 64; s++) {
      if (colorOf(brd[s]) === color) {
        if (getDiagTargets(s, brd, color).includes(ks)) {
          score += 1.2;
        }
      }
    }
  }
  return score;
}

function fractalDiagScore(square, brd, color, depth = 3) {
  let score = 0;
  const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
  dirs.forEach(([dr, df]) => {
    let nr = rankOf(square) + dr, nf = fileOf(square) + df;
    let segLen = 0, patternHash = 0;
    let currentDepth = depth;
    while (inBounds(nr, nf) && currentDepth > 0) {
      const s = idx(nr, nf);
      const occupied = !!brd[s];
      patternHash = (patternHash * 3 + (occupied ? 1 : 0) + (colorOf(brd[s]) === color ? 2 : 0)) % 997;
      if (!occupied) segLen++;
      nr += dr; nf += df;
      currentDepth--;
    }
    score += segLen * (1 + Math.log2(segLen + 1)) + (patternHash % 13 === 0 ? 8 : 0);
  });
  return score;
}

// ============================================================
// NAND AI ENGINE — FRACTAL DIAGONAL BROWSER
// ============================================================
function computePressureMap() {
  pressureMap = new Array(64).fill(0);
  for (let s = 0; s < 64; s++) {
    if (colorOf(board[s]) === 'b') {
      const targets = getDiagTargets(s, board, 'b');
      targets.forEach(t => {
        pressureMap[t] += 1;
        if (pressureMap[t] > 4) pressureMap[t] = 4;
      });
    }
  }
}

function nandEvaluateBoard(brd, forColor = 'b') {
  let score = 0;
  const vals = { P:1, N:2, B:4, R:3, Q:10, K:0 };
  for (let s = 0; s < 64; s++) {
    const p = brd[s];
    if (p) {
      const sign = colorOf(p) === forColor ? 1 : -1;
      score += sign * vals[typeOf(p)] * 10;
    }
  }

  const blackMob = diagMobility(brd, 'b');
  const whiteMob = diagMobility(brd, 'w');
  score += blackMob * 2 - whiteMob * 3;
  score += keyDiagControl(brd, 'b') * 5;

  let kingSq = brd.findIndex(p => p === forColor + 'K');
  score += fractalDiagScore(kingSq, brd, forColor) * 1.5;

  const enemy = forColor === 'b' ? 'w' : 'b';
  if (isInCheck(enemy, brd)) score += 20;
  if (!hasAnyLegalMove(enemy, brd)) score += 10000;

  return score;
}

function nandEvaluateMove(from, to, brd) {
  const nb = brd.slice();
  nb[to] = nb[from];
  nb[from] = null;
  if (typeOf(nb[to]) === 'P' && rankOf(to) === 7) nb[to] = 'bQ';

  let score = nandEvaluateBoard(nb, 'b');

  const diagDirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
  const primeSteps = [1,2,3,5,7];
  const nandInputs = new Array(8).fill(0);
  let idx = 0;
  for (let step of primeSteps) {
    for (let dir of diagDirs) {
      if (idx >= 8) break;
      const nr = rankOf(to) + dir[0] * step;
      const nf = fileOf(to) + dir[1] * step;
      if (!inBounds(nr,nf)) { nandInputs[idx++] = 0; continue; }
      const sq = idx(nr,nf);
      const open = !nb[sq] || colorOf(nb[sq]) !== 'b';
      nandInputs[idx++] = open ? 1 : 0;
    }
  }

  const { remainder: newRemainder, fired } = cycleNANDRing(nandInputs.slice());

  let ringScore = fired.length * 4;
  const remWeight = (newRemainder.toString(2).match(/1/g) || []).length;
  ringScore += (8 - remWeight) * 2;

  const diagDist = Math.abs(rankOf(to) - rankOf(from)) === Math.abs(fileOf(to) - fileOf(from))
    ? Math.abs(rankOf(to) - rankOf(from)) : 0;
  if (diagDist > 0 && (newRemainder & 1) === (diagDist % 2)) {
    ringScore += 6 + diagDist * 2;
  }

  if (isInCheck('w', nb)) ringScore *= 1.5;

  const oldRemainder = nandRemainder;
  if ((newRemainder ^ oldRemainder) === 0) {
    ringScore += 8;
  } else if (bitCount(newRemainder ^ oldRemainder) <= 2) {
    ringScore += 4;
  }

  score += ringScore;
  score += fractalDiagScore(to, nb, 'b') * 5 - fractalDiagScore(to, nb, 'w') * 7;

  if (isInCheck('b', nb)) score -= 100;

  return score;
}

function bitCount(n) {
  return n.toString(2).split('1').length - 1;
}

// MINIMAX WITH ALPHA-BETA FOR BETTER THAN BEGINNER AI
const MAX_DEPTH = 3;

function minimax(brd, depth, alpha, beta, isMax) {
  if (depth === 0) return nandEvaluateBoard(brd, 'b');

  const color = isMax ? 'b' : 'w';
  let best = isMax ? -Infinity : Infinity;

  for (let s = 0; s < 64; s++) {
    if (colorOf(brd[s]) === color) {
      const moves = getLegalMoves(s, brd, color);
      for (let to of moves) {
        const nb = brd.slice();
        nb[to] = nb[s];
        nb[s] = null;
        if (typeOf(nb[to]) === 'P' && (rankOf(to) === 0 || rankOf(to) === 7)) nb[to] = color + 'Q';

        const val = minimax(nb, depth - 1, alpha, beta, !isMax);

        if (isMax) {
          best = Math.max(best, val);
          alpha = Math.max(alpha, best);
        } else {
          best = Math.min(best, val);
          beta = Math.min(beta, best);
        }
        if (beta <= alpha) return best;
      }
    }
  }
  return best;
}

function getAIMove() {
  let bestScore = -Infinity;
  let bestMove = null;

  for (let s = 0; s < 64; s++) {
    if (colorOf(board[s]) !== 'b') continue;
    const moves = getLegalMoves(s, board, 'b');
    for (let to of moves) {
      const nb = board.slice();
      nb[to] = nb[s];
      nb[s] = null;
      if (typeOf(nb[to]) === 'P' && rankOf(to) === 7) nb[to] = 'bQ';

      const score = minimax(nb, MAX_DEPTH - 1, -Infinity, Infinity, false); // false because after AI move, min for player

      if (score > bestScore) {
        bestScore = score;
        bestMove = { from: s, to };
      }
    }
  }
  return bestMove;
}

// ============================================================
// UI AND GAME LOGIC
// ============================================================
function squareName(sq) {
  return FILES[fileOf(sq)] + RANKS[rankOf(sq)];
}
function toAlgebraic(from, to, promotion) {
  const piece = board[from];
  const t = typeOf(piece);
  const capture = board[to] ? 'x' : '';
  const prom = promotion ? '=' + promotion : '';
  if (t === 'P') return FILES[fileOf(from)] + (capture ? 'x' : '') + squareName(to) + prom;
  return t + capture + squareName(to);
}
function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';
  computePressureMap();
  for (let s = 0; s < 64; s++) {
    const r = rankOf(s), f = fileOf(s);
    const cell = document.createElement('div');
    cell.className = 'cell ' + ((r + f) % 2 === 0 ? 'light' : 'dark');
    cell.dataset.sq = s;
    const p = pressureMap[s];
    if (p >= 1) cell.classList.add('pressure-' + Math.min(4, p));
    if (p >= 2) cell.classList.add('diagonal-threat');
    if (selected === s) cell.classList.add('selected');
    if (validMoves.includes(s)) {
      cell.classList.add('valid-move');
      if (board[s]) cell.classList.add('has-piece');
    }
    if (lastMoveSquares.includes(s)) cell.classList.add('last-move');
    if (board[s]) {
      const pieceEl = document.createElement('div');
      pieceEl.className = 'piece';
      pieceEl.style.color = colorOf(board[s]) === 'w' ? '#d0f0ff' : '#ff8866';
      pieceEl.textContent = PIECES[board[s]];
      cell.appendChild(pieceEl);
    }
    cell.addEventListener('click', () => onCellClick(s));
    boardEl.appendChild(cell);
  }
}
function onCellClick(sq) {
  if (!gameActive || currentTurn !== 'w') return;
  if (selected !== null && validMoves.includes(sq)) {
    executeMove('w', selected, sq);
    selected = null;
    validMoves = [];
    renderBoard();
    setTimeout(() => {
      if (gameActive) triggerAIMove();
    }, 400);
    return;
  }
  if (board[sq] && colorOf(board[sq]) === 'w') {
    selected = sq;
    validMoves = getLegalMoves(sq);
  } else {
    selected = null;
    validMoves = [];
  }
  renderBoard();
}
function executeMove(color, from, to) {
  const alg = toAlgebraic(from, to, null);
  const captured = board[to];
  lastMoveSquares = [from, to];
  board[to] = board[from];
  board[from] = null;
  if (typeOf(board[to]) === 'P') {
    if (rankOf(to) === 0 && color === 'w') board[to] = 'wQ';
    if (rankOf(to) === 7 && color === 'b') board[to] = 'bQ';
  }
  moveCount++;
  moveHistory.push({ color, from, to, alg, captured });
  updateMoveList();
  const inputs = [];
  for (let i = 0; i < 8; i++) {
    inputs.push((from + to + i) % 2);
  }
  const { remainder, fired } = cycleNANDRing(inputs);
  animateNANDRing(fired);
  updateNANDDisplay(remainder, fired, color, alg);
  const enemy = color === 'w' ? 'b' : 'w';
  if (!hasAnyLegalMove(enemy)) {
    if (isInCheck(enemy, board)) {
      endGame(color === 'w' ? 'win' : 'lose');
    } else {
      endGame('draw');
    }
    return;
  }
  currentTurn = enemy;
  updateTurnUI();
}
function triggerAIMove() {
  const move = getAIMove();
  if (!move) {
    endGame(hasAnyLegalMove('b') ? 'draw' : 'win');
    return;
  }
  executeMove('b', move.from, move.to);
  renderBoard();
  updateTurnUI();
}
function updateTurnUI() {
  const dot = document.getElementById('turnDot');
  const text = document.getElementById('turnText');
  const bar = document.getElementById('statusBar');
  if (currentTurn === 'w') {
    dot.className = 'turn-dot';
    text.textContent = 'YOUR MOVE';
    bar.textContent = 'AWAITING PLAYER INPUT — DIAGONAL FIELD ACTIVE';
  } else {
    dot.className = 'turn-dot ai';
    text.textContent = 'AI COMPUTING';
    bar.textContent = 'NAND ENGINE EVALUATING — CYCLIC REMAINDER PROPAGATING...';
  }
  const totalPressure = pressureMap.reduce((a,b) => a+b, 0);
  const maxP = 200;
  document.getElementById('pressureFill').style.width = Math.min(100, totalPressure / maxP * 100) + '%';
  document.getElementById('nandFill').style.width = (nandRemainder / 2.55) + '%';
}
function animateNANDRing(fired) {
  document.querySelectorAll('.nand-cell').forEach((el, i) => {
    el.className = 'nand-cell';
    if (fired.includes(i)) {
      el.classList.add('fired');
      el.style.background = `hsl(${ (i * 45) % 360 }, 80%, 50%)`;
      setTimeout(() => el.classList.add('active'), 300);
    } else {
      el.classList.add('active');
    }
  });
}
function updateNANDDisplay(remainder, fired, color, move) {
  document.getElementById('phaseDisplay').textContent = nandPhase + 'π/4';
  document.getElementById('remainderDisplay').textContent = '0x' + nandRemainder.toString(16).padStart(2,'0').toUpperCase();
  const log = document.getElementById('nandLog');
  const entry = document.createElement('div');
  entry.className = 'log-entry ' + (color === 'w' ? 'player' : 'ai');
  const gateOps = fired.map(i => `G${i}:T=1`).join(' ');
  entry.textContent = `[${color === 'w' ? 'PLY' : 'AI '}] ${move} | R=${remainder} | ${gateOps || 'stable'} | Σ=${nandRemainder}`;
  log.insertBefore(entry, log.firstChild);
  if (log.children.length > 30) log.removeChild(log.lastChild);
}
function updateMoveList() {
  const ml = document.getElementById('moveList');
  ml.innerHTML = '';
  let wMoves = moveHistory.filter(m => m.color === 'w');
  let bMoves = moveHistory.filter(m => m.color === 'b');
  const maxNum = Math.max(wMoves.length, bMoves.length);
  for (let i = 0; i < maxNum; i++) {
    const numEl = document.createElement('div');
    numEl.className = 'move-num';
    numEl.textContent = (i+1) + '.';
    const wEl = document.createElement('div');
    wEl.className = 'move-player';
    wEl.textContent = wMoves[i] ? wMoves[i].alg : '';
    const bEl = document.createElement('div');
    bEl.className = 'move-ai';
    bEl.textContent = bMoves[i] ? bMoves[i].alg : '';
    ml.appendChild(numEl);
    ml.appendChild(wEl);
    ml.appendChild(bEl);
  }
  ml.scrollTop = ml.scrollHeight;
}
function endGame(result) {
  gameActive = false;
  const overlay = document.getElementById('gameOverlay');
  const title = document.getElementById('gameOverTitle');
  const sub = document.getElementById('gameOverSub');
  overlay.classList.add('show');
  if (result === 'win') {
    title.textContent = 'CHECKMATE'; title.className = 'game-over-title win';
    sub.textContent = 'YOU ESCAPED THE NAND FIELD';
  } else if (result === 'lose') {
    title.textContent = 'CHECKMATE'; title.className = 'game-over-title lose';
    sub.textContent = 'DIAGONAL CONSTRAINT ACHIEVED — NAND ENGINE PREVAILS';
  } else {
    title.textContent = 'STALEMATE'; title.className = 'game-over-title';
    sub.textContent = 'REMAINDER = 0 — CYCLIC EQUILIBRIUM';
  }
}
function buildNANDCircuit() {
  const circuit = document.getElementById('nandCircuit');
  circuit.innerHTML = '';
  for (let i = 0; i < 8; i++) {
    const cell = document.createElement('div');
    cell.className = 'nand-cell active';
    cell.textContent = i;
    cell.title = `Cell ${i} — Phase ${i}π/4`;
    circuit.appendChild(cell);
  }
}
function addSystemLog(msg) {
  const log = document.getElementById('nandLog');
  const entry = document.createElement('div');
  entry.className = 'log-entry system';
  entry.textContent = msg;
  log.insertBefore(entry, log.firstChild);
}
function buildLabels() {
  const left = document.getElementById('labelsLeft');
  const bottom = document.getElementById('labelsBottom');
  RANKS.forEach(r => {
    const s = document.createElement('span');
    s.textContent = r;
    left.appendChild(s);
  });
  FILES.forEach(f => {
    const s = document.createElement('span');
    s.textContent = f;
    bottom.appendChild(s);
  });
}
function resetGame() {
  board = [];
  selected = null;
  validMoves = [];
  currentTurn = 'w';
  gameActive = true;
  moveHistory = [];
  nandRing = new Array(8).fill(0);
  nandPhase = 0;
  nandRemainder = 0;
  pressureMap = new Array(64).fill(0);
  lastMoveSquares = [];
  moveCount = 0;
  document.getElementById('gameOverlay').classList.remove('show');
  initBoard();
  buildNANDCircuit();
  renderBoard();
  updateTurnUI();
  document.getElementById('nandLog').innerHTML = '';
  document.getElementById('moveList').innerHTML = '';
  addSystemLog('[SYS] NAND ring initialized — 8-cell cyclic array online');
  addSystemLog('[SYS] Diagonal Logic Engine v1.0 ready');
}
// INIT
buildLabels();
resetGame();
</script>
</body>
</html>
